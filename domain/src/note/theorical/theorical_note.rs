use std::fmt;

use crate::accident::Accident;

use super::base_note::BaseNote;

#[derive(Debug, PartialEq, Clone)]
pub struct TheoricalNote {
    pub base: BaseNote,
    pub accident: Accident,
}

impl fmt::Display for TheoricalNote {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.to_str())
    }
}

impl TheoricalNote {
    pub fn try_from_str(value: &str) -> Option<TheoricalNote> {
        match value {
            "C‚ô≠‚ô≠" | "CùÑ´" => Some(TheoricalNote { base: BaseNote::C, accident: Accident::DoubleFlat }),
            "C‚ô≠" => Some(TheoricalNote { base: BaseNote::C, accident: Accident::Flat }),
            "C" | "C‚ôÆ" => Some(TheoricalNote { base: BaseNote::C, accident: Accident::Natural }),
            "C‚ôØ" => Some(TheoricalNote { base: BaseNote::C, accident: Accident::Sharp }),
            "C‚ôØ‚ôØ" | "CùÑ™" => Some(TheoricalNote { base: BaseNote::C, accident: Accident::DoubleSharp }),

            "D‚ô≠‚ô≠" | "DùÑ´" => Some(TheoricalNote { base: BaseNote::D, accident: Accident::DoubleFlat }),
            "D‚ô≠" => Some(TheoricalNote { base: BaseNote::D, accident: Accident::Flat }),
            "D" | "D‚ôÆ" => Some(TheoricalNote { base: BaseNote::D, accident: Accident::Natural }),
            "D‚ôØ" => Some(TheoricalNote { base: BaseNote::D, accident: Accident::Sharp }),
            "D‚ôØ‚ôØ" | "DùÑ™" => Some(TheoricalNote { base: BaseNote::D, accident: Accident::DoubleSharp }),

            "E‚ô≠‚ô≠" | "EùÑ´" => Some(TheoricalNote { base: BaseNote::E, accident: Accident::DoubleFlat }),
            "E‚ô≠" => Some(TheoricalNote { base: BaseNote::E, accident: Accident::Flat }),
            "E" | "E‚ôÆ" => Some(TheoricalNote { base: BaseNote::E, accident: Accident::Natural }),
            "E‚ôØ" => Some(TheoricalNote { base: BaseNote::E, accident: Accident::Sharp }),
            "E‚ôØ‚ôØ" | "EùÑ™" => Some(TheoricalNote { base: BaseNote::E, accident: Accident::DoubleSharp }),

            "F‚ô≠‚ô≠" | "FùÑ´" => Some(TheoricalNote { base: BaseNote::F, accident: Accident::DoubleFlat }),
            "F‚ô≠" => Some(TheoricalNote { base: BaseNote::F, accident: Accident::Flat }),
            "F" | "F‚ôÆ" => Some(TheoricalNote { base: BaseNote::F, accident: Accident::Natural }),
            "F‚ôØ" => Some(TheoricalNote { base: BaseNote::F, accident: Accident::Sharp }),
            "F‚ôØ‚ôØ" | "FùÑ™" => Some(TheoricalNote { base: BaseNote::F, accident: Accident::DoubleSharp }),

            "G‚ô≠‚ô≠" | "GùÑ´" => Some(TheoricalNote { base: BaseNote::G, accident: Accident::DoubleFlat }),
            "G‚ô≠" => Some(TheoricalNote { base: BaseNote::G, accident: Accident::Flat }),
            "G" | "G‚ôÆ" => Some(TheoricalNote { base: BaseNote::G, accident: Accident::Natural }),
            "G‚ôØ" => Some(TheoricalNote { base: BaseNote::G, accident: Accident::Sharp }),
            "G‚ôØ‚ôØ" | "GùÑ™" => Some(TheoricalNote { base: BaseNote::G, accident: Accident::DoubleSharp }),

            "A‚ô≠‚ô≠" | "AùÑ´" => Some(TheoricalNote { base: BaseNote::A, accident: Accident::DoubleFlat }),
            "A‚ô≠" => Some(TheoricalNote { base: BaseNote::A, accident: Accident::Flat }),
            "A" | "A‚ôÆ" => Some(TheoricalNote { base: BaseNote::A, accident: Accident::Natural }),
            "A‚ôØ" => Some(TheoricalNote { base: BaseNote::A, accident: Accident::Sharp }),
            "A‚ôØ‚ôØ" | "AùÑ™" => Some(TheoricalNote { base: BaseNote::A, accident: Accident::DoubleSharp }),

            "B‚ô≠‚ô≠" | "BùÑ´" => Some(TheoricalNote { base: BaseNote::B, accident: Accident::DoubleFlat }),
            "B‚ô≠" => Some(TheoricalNote { base: BaseNote::B, accident: Accident::Flat }),
            "B" | "B‚ôÆ" => Some(TheoricalNote { base: BaseNote::B, accident: Accident::Natural }),
            "B‚ôØ" => Some(TheoricalNote { base: BaseNote::B, accident: Accident::Sharp }),
            "B‚ôØ‚ôØ" | "BùÑ™" => Some(TheoricalNote { base: BaseNote::B, accident: Accident::DoubleSharp }),
            _ => None,
        }
    }

    pub fn from_str(value: &str) -> TheoricalNote {
        Self::try_from_str(value).unwrap()
    }

    pub fn to_str(&self) -> String {
        match self {
            TheoricalNote { base: BaseNote::C, accident: Accident::DoubleFlat } => "CùÑ´".into(),
            TheoricalNote { base: BaseNote::C, accident: Accident::Flat } => "C‚ô≠".into(),
            TheoricalNote { base: BaseNote::C, accident: Accident::Natural } => "C".into(),
            TheoricalNote { base: BaseNote::C, accident: Accident::Sharp } => "C‚ôØ".into(),
            TheoricalNote { base: BaseNote::C, accident: Accident::DoubleSharp } => "CùÑ™".into(),

            TheoricalNote { base: BaseNote::D, accident: Accident::DoubleFlat } => "DùÑ´".into(),
            TheoricalNote { base: BaseNote::D, accident: Accident::Flat } => "D‚ô≠".into(),
            TheoricalNote { base: BaseNote::D, accident: Accident::Natural } => "D".into(),
            TheoricalNote { base: BaseNote::D, accident: Accident::Sharp } => "D‚ôØ".into(),
            TheoricalNote { base: BaseNote::D, accident: Accident::DoubleSharp } => "DùÑ™".into(),

            TheoricalNote { base: BaseNote::E, accident: Accident::DoubleFlat } => "EùÑ´".into(),
            TheoricalNote { base: BaseNote::E, accident: Accident::Flat } => "E‚ô≠".into(),
            TheoricalNote { base: BaseNote::E, accident: Accident::Natural } => "E".into(),
            TheoricalNote { base: BaseNote::E, accident: Accident::Sharp } => "E‚ôØ".into(),
            TheoricalNote { base: BaseNote::E, accident: Accident::DoubleSharp } => "EùÑ™".into(),

            TheoricalNote { base: BaseNote::F, accident: Accident::DoubleFlat } => "FùÑ´".into(),
            TheoricalNote { base: BaseNote::F, accident: Accident::Flat } => "F‚ô≠".into(),
            TheoricalNote { base: BaseNote::F, accident: Accident::Natural } => "F".into(),
            TheoricalNote { base: BaseNote::F, accident: Accident::Sharp } => "F‚ôØ".into(),
            TheoricalNote { base: BaseNote::F, accident: Accident::DoubleSharp } => "FùÑ™".into(),

            TheoricalNote { base: BaseNote::G, accident: Accident::DoubleFlat } => "GùÑ´".into(),
            TheoricalNote { base: BaseNote::G, accident: Accident::Flat } => "G‚ô≠".into(),
            TheoricalNote { base: BaseNote::G, accident: Accident::Natural } => "G".into(),
            TheoricalNote { base: BaseNote::G, accident: Accident::Sharp } => "G‚ôØ".into(),
            TheoricalNote { base: BaseNote::G, accident: Accident::DoubleSharp } => "GùÑ™".into(),

            TheoricalNote { base: BaseNote::A, accident: Accident::DoubleFlat } => "AùÑ´".into(),
            TheoricalNote { base: BaseNote::A, accident: Accident::Flat } => "A‚ô≠".into(),
            TheoricalNote { base: BaseNote::A, accident: Accident::Natural } => "A".into(),
            TheoricalNote { base: BaseNote::A, accident: Accident::Sharp } => "A‚ôØ".into(),
            TheoricalNote { base: BaseNote::A, accident: Accident::DoubleSharp } => "AùÑ™".into(),

            TheoricalNote { base: BaseNote::B, accident: Accident::DoubleFlat } => "BùÑ´".into(),
            TheoricalNote { base: BaseNote::B, accident: Accident::Flat } => "B‚ô≠".into(),
            TheoricalNote { base: BaseNote::B, accident: Accident::Natural } => "B".into(),
            TheoricalNote { base: BaseNote::B, accident: Accident::Sharp } => "B‚ôØ".into(),
            TheoricalNote { base: BaseNote::B, accident: Accident::DoubleSharp } => "BùÑ™".into(),
        }
    }
}

pub fn vec_of_vec_str(value: Vec<&str>) -> Vec<TheoricalNote> {
    value.iter().map(|val| TheoricalNote::try_from_str(val)).filter_map(|num| num).collect()
}

pub fn vec_of_slice_str<const N: usize>(value: [&str; N]) -> Vec<TheoricalNote> {
    value.to_vec().iter().map(|val| TheoricalNote::try_from_str(val)).filter_map(|num| num).collect()
}

#[cfg(test)]
mod tests {
    use crate::accident::Accident;

    use super::{BaseNote, TheoricalNote, vec_of_slice_str, vec_of_vec_str};

    #[test]
    fn try_from_str_c() {
        assert_eq!(TheoricalNote::try_from_str("C‚ô≠‚ô≠"), Some(TheoricalNote { base: BaseNote::C, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("CùÑ´"), Some(TheoricalNote { base: BaseNote::C, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("C‚ô≠"), Some(TheoricalNote { base: BaseNote::C, accident: Accident::Flat }));
        assert_eq!(TheoricalNote::try_from_str("C"), Some(TheoricalNote { base: BaseNote::C, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("C‚ôÆ"), Some(TheoricalNote { base: BaseNote::C, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("C‚ôØ"), Some(TheoricalNote { base: BaseNote::C, accident: Accident::Sharp }));
        assert_eq!(TheoricalNote::try_from_str("C‚ôØ‚ôØ"), Some(TheoricalNote { base: BaseNote::C, accident: Accident::DoubleSharp }));
        assert_eq!(TheoricalNote::try_from_str("CùÑ™"), Some(TheoricalNote { base: BaseNote::C, accident: Accident::DoubleSharp }));
    }

    #[test]
    fn try_from_str_d() {
        assert_eq!(TheoricalNote::try_from_str("D‚ô≠‚ô≠"), Some(TheoricalNote { base: BaseNote::D, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("DùÑ´"), Some(TheoricalNote { base: BaseNote::D, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("D‚ô≠"), Some(TheoricalNote { base: BaseNote::D, accident: Accident::Flat }));
        assert_eq!(TheoricalNote::try_from_str("D"), Some(TheoricalNote { base: BaseNote::D, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("D‚ôÆ"), Some(TheoricalNote { base: BaseNote::D, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("D‚ôØ"), Some(TheoricalNote { base: BaseNote::D, accident: Accident::Sharp }));
        assert_eq!(TheoricalNote::try_from_str("D‚ôØ‚ôØ"), Some(TheoricalNote { base: BaseNote::D, accident: Accident::DoubleSharp }));
        assert_eq!(TheoricalNote::try_from_str("DùÑ™"), Some(TheoricalNote { base: BaseNote::D, accident: Accident::DoubleSharp }));
    }

    #[test]
    fn try_from_str_e() {
        assert_eq!(TheoricalNote::try_from_str("E‚ô≠‚ô≠"), Some(TheoricalNote { base: BaseNote::E, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("EùÑ´"), Some(TheoricalNote { base: BaseNote::E, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("E‚ô≠"), Some(TheoricalNote { base: BaseNote::E, accident: Accident::Flat }));
        assert_eq!(TheoricalNote::try_from_str("E"), Some(TheoricalNote { base: BaseNote::E, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("E‚ôÆ"), Some(TheoricalNote { base: BaseNote::E, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("E‚ôØ"), Some(TheoricalNote { base: BaseNote::E, accident: Accident::Sharp }));
        assert_eq!(TheoricalNote::try_from_str("E‚ôØ‚ôØ"), Some(TheoricalNote { base: BaseNote::E, accident: Accident::DoubleSharp }));
        assert_eq!(TheoricalNote::try_from_str("EùÑ™"), Some(TheoricalNote { base: BaseNote::E, accident: Accident::DoubleSharp }));
    }

    #[test]
    fn try_from_str_f() {
        assert_eq!(TheoricalNote::try_from_str("F‚ô≠‚ô≠"), Some(TheoricalNote { base: BaseNote::F, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("FùÑ´"), Some(TheoricalNote { base: BaseNote::F, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("F‚ô≠"), Some(TheoricalNote { base: BaseNote::F, accident: Accident::Flat }));
        assert_eq!(TheoricalNote::try_from_str("F"), Some(TheoricalNote { base: BaseNote::F, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("F‚ôÆ"), Some(TheoricalNote { base: BaseNote::F, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("F‚ôØ"), Some(TheoricalNote { base: BaseNote::F, accident: Accident::Sharp }));
        assert_eq!(TheoricalNote::try_from_str("F‚ôØ‚ôØ"), Some(TheoricalNote { base: BaseNote::F, accident: Accident::DoubleSharp }));
        assert_eq!(TheoricalNote::try_from_str("FùÑ™"), Some(TheoricalNote { base: BaseNote::F, accident: Accident::DoubleSharp }));
    }

    #[test]
    fn try_from_str_g() {
        assert_eq!(TheoricalNote::try_from_str("G‚ô≠‚ô≠"), Some(TheoricalNote { base: BaseNote::G, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("GùÑ´"), Some(TheoricalNote { base: BaseNote::G, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("G‚ô≠"), Some(TheoricalNote { base: BaseNote::G, accident: Accident::Flat }));
        assert_eq!(TheoricalNote::try_from_str("G"), Some(TheoricalNote { base: BaseNote::G, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("G‚ôÆ"), Some(TheoricalNote { base: BaseNote::G, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("G‚ôØ"), Some(TheoricalNote { base: BaseNote::G, accident: Accident::Sharp }));
        assert_eq!(TheoricalNote::try_from_str("G‚ôØ‚ôØ"), Some(TheoricalNote { base: BaseNote::G, accident: Accident::DoubleSharp }));
        assert_eq!(TheoricalNote::try_from_str("GùÑ™"), Some(TheoricalNote { base: BaseNote::G, accident: Accident::DoubleSharp }));
    }

    #[test]
    fn try_from_str_a() {
        assert_eq!(TheoricalNote::try_from_str("A‚ô≠‚ô≠"), Some(TheoricalNote { base: BaseNote::A, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("AùÑ´"), Some(TheoricalNote { base: BaseNote::A, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("A‚ô≠"), Some(TheoricalNote { base: BaseNote::A, accident: Accident::Flat }));
        assert_eq!(TheoricalNote::try_from_str("A"), Some(TheoricalNote { base: BaseNote::A, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("A‚ôÆ"), Some(TheoricalNote { base: BaseNote::A, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("A‚ôØ"), Some(TheoricalNote { base: BaseNote::A, accident: Accident::Sharp }));
        assert_eq!(TheoricalNote::try_from_str("A‚ôØ‚ôØ"), Some(TheoricalNote { base: BaseNote::A, accident: Accident::DoubleSharp }));
        assert_eq!(TheoricalNote::try_from_str("AùÑ™"), Some(TheoricalNote { base: BaseNote::A, accident: Accident::DoubleSharp }));
    }

    #[test]
    fn try_from_str_b() {
        assert_eq!(TheoricalNote::try_from_str("B‚ô≠‚ô≠"), Some(TheoricalNote { base: BaseNote::B, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("BùÑ´"), Some(TheoricalNote { base: BaseNote::B, accident: Accident::DoubleFlat }));
        assert_eq!(TheoricalNote::try_from_str("B‚ô≠"), Some(TheoricalNote { base: BaseNote::B, accident: Accident::Flat }));
        assert_eq!(TheoricalNote::try_from_str("B"), Some(TheoricalNote { base: BaseNote::B, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("B‚ôÆ"), Some(TheoricalNote { base: BaseNote::B, accident: Accident::Natural }));
        assert_eq!(TheoricalNote::try_from_str("B‚ôØ"), Some(TheoricalNote { base: BaseNote::B, accident: Accident::Sharp }));
        assert_eq!(TheoricalNote::try_from_str("B‚ôØ‚ôØ"), Some(TheoricalNote { base: BaseNote::B, accident: Accident::DoubleSharp }));
        assert_eq!(TheoricalNote::try_from_str("BùÑ™"), Some(TheoricalNote { base: BaseNote::B, accident: Accident::DoubleSharp }));
    }

    #[test]
    fn try_from_str_none() {
        assert_eq!(TheoricalNote::try_from_str("H"), None);
        assert_eq!(TheoricalNote::try_from_str("I"), None);
        assert_eq!(TheoricalNote::try_from_str("J"), None);
    }

    #[test]
    fn from_str() {
        assert_eq!(TheoricalNote::from_str("C‚ô≠‚ô≠"), TheoricalNote { base: BaseNote::C, accident: Accident::DoubleFlat });
        assert_eq!(TheoricalNote::from_str("D‚ô≠"), TheoricalNote { base: BaseNote::D, accident: Accident::Flat });
        assert_eq!(TheoricalNote::from_str("E"), TheoricalNote { base: BaseNote::E, accident: Accident::Natural });
        assert_eq!(TheoricalNote::from_str("F‚ôØ"), TheoricalNote { base: BaseNote::F, accident: Accident::Sharp });
        assert_eq!(TheoricalNote::from_str("G‚ôØ‚ôØ"), TheoricalNote { base: BaseNote::G, accident: Accident::DoubleSharp });
    }

    #[test]
    fn to_string() {
        assert_eq!(TheoricalNote { base: BaseNote::C, accident: Accident::DoubleFlat }.to_string(), "CùÑ´".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::C, accident: Accident::Flat }.to_string(), "C‚ô≠".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::C, accident: Accident::Natural }.to_string(), "C".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::C, accident: Accident::Sharp }.to_string(), "C‚ôØ".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::C, accident: Accident::DoubleSharp }.to_string(), "CùÑ™".to_string());

        assert_eq!(TheoricalNote { base: BaseNote::D, accident: Accident::DoubleFlat }.to_string(), "DùÑ´".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::D, accident: Accident::Flat }.to_string(), "D‚ô≠".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::D, accident: Accident::Natural }.to_string(), "D".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::D, accident: Accident::Sharp }.to_string(), "D‚ôØ".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::D, accident: Accident::DoubleSharp }.to_string(), "DùÑ™".to_string());

        assert_eq!(TheoricalNote { base: BaseNote::E, accident: Accident::DoubleFlat }.to_string(), "EùÑ´".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::E, accident: Accident::Flat }.to_string(), "E‚ô≠".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::E, accident: Accident::Natural }.to_string(), "E".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::E, accident: Accident::Sharp }.to_string(), "E‚ôØ".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::E, accident: Accident::DoubleSharp }.to_string(), "EùÑ™".to_string());

        assert_eq!(TheoricalNote { base: BaseNote::F, accident: Accident::DoubleFlat }.to_string(), "FùÑ´".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::F, accident: Accident::Flat }.to_string(), "F‚ô≠".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::F, accident: Accident::Natural }.to_string(), "F".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::F, accident: Accident::Sharp }.to_string(), "F‚ôØ".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::F, accident: Accident::DoubleSharp }.to_string(), "FùÑ™".to_string());

        assert_eq!(TheoricalNote { base: BaseNote::G, accident: Accident::DoubleFlat }.to_string(), "GùÑ´".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::G, accident: Accident::Flat }.to_string(), "G‚ô≠".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::G, accident: Accident::Natural }.to_string(), "G".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::G, accident: Accident::Sharp }.to_string(), "G‚ôØ".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::G, accident: Accident::DoubleSharp }.to_string(), "GùÑ™".to_string());

        assert_eq!(TheoricalNote { base: BaseNote::A, accident: Accident::DoubleFlat }.to_string(), "AùÑ´".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::A, accident: Accident::Flat }.to_string(), "A‚ô≠".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::A, accident: Accident::Natural }.to_string(), "A".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::A, accident: Accident::Sharp }.to_string(), "A‚ôØ".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::A, accident: Accident::DoubleSharp }.to_string(), "AùÑ™".to_string());

        assert_eq!(TheoricalNote { base: BaseNote::B, accident: Accident::DoubleFlat }.to_string(), "BùÑ´".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::B, accident: Accident::Flat }.to_string(), "B‚ô≠".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::B, accident: Accident::Natural }.to_string(), "B".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::B, accident: Accident::Sharp }.to_string(), "B‚ôØ".to_string());
        assert_eq!(TheoricalNote { base: BaseNote::B, accident: Accident::DoubleSharp }.to_string(), "BùÑ™".to_string());
    }

    #[test]
    fn test_vec_of_vec_str() {
        assert_eq!(
            vec_of_vec_str(vec!["CùÑ´", "D‚ô≠", "E", "F", "G", "A‚ôØ", "BùÑ™"]),
            vec![
                TheoricalNote::from_str("CùÑ´"),
                TheoricalNote::from_str("D‚ô≠"),
                TheoricalNote::from_str("E"),
                TheoricalNote::from_str("F"),
                TheoricalNote::from_str("G"),
                TheoricalNote::from_str("A‚ôØ"),
                TheoricalNote::from_str("BùÑ™"),
            ]
        );
    }

    #[test]
    fn test_vec_of_slice_str() {
        assert_eq!(
            vec_of_slice_str(["CùÑ´", "D‚ô≠", "E", "F", "G", "A‚ôØ", "BùÑ™"]),
            vec![
                TheoricalNote::from_str("CùÑ´"),
                TheoricalNote::from_str("D‚ô≠"),
                TheoricalNote::from_str("E"),
                TheoricalNote::from_str("F"),
                TheoricalNote::from_str("G"),
                TheoricalNote::from_str("A‚ôØ"),
                TheoricalNote::from_str("BùÑ™"),
            ]
        );
    }
}
